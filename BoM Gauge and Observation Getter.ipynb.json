{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# BoM gauge and observation getter"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setup the dependencies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "https://jakevdp.github.io/blog/2017/12/05/installing-python-packages-from-jupyter/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import sys\n",
    "!{sys.executable} -m pip install ciso8601"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!{sys.executable} -m pip install lxml"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import datetime\n",
    "import pytz\n",
    "import ciso8601\n",
    "from types import SimpleNamespace\n",
    "import requests\n",
    "import lxml\n",
    "import lxml.etree\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Get the list of stations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_stations(time=None,\n",
    "                 observation='http://bom.gov.au/waterdata/services/parameters/Water Course Discharge',\n",
    "                 url='http://www.bom.gov.au/waterdata/services'):\n",
    "    \"\"\" Get list of stations\n",
    "        :param time: tuple of datetime.datetime objects, or None to query from 1980-1-1 to Now\n",
    "        Returns\n",
    "        ========\n",
    "        List of stations:\n",
    "         .name -- string, human readable station name\n",
    "         .pos  -- Coordinate of the station or None\n",
    "         .url  -- service url identifier\n",
    "    \"\"\"\n",
    "\n",
    "    data = tpl_get_stations.format(observation=observation,\n",
    "                                   **_fmt_time(time))\n",
    "    rr = requests.post(url, data=data)\n",
    "\n",
    "    return _parse_station_data(rr.text)\n",
    "\n",
    "##########################\n",
    "\n",
    "tpl_get_stations = '''\n",
    "<soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"\n",
    "  xmlns:sos=\"http://www.opengis.net/sos/2.0\"\n",
    "  xmlns:wsa=\"http://www.w3.org/2005/08/addressing\"\n",
    "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n",
    "  xmlns:ows=\"http://www.opengis.net/ows/1.1\"\n",
    "  xmlns:fes=\"http://www.opengis.net/fes/2.0\"\n",
    "  xmlns:gml=\"http://www.opengis.net/gml/3.2\"\n",
    "  xmlns:swes=\"http://www.opengis.net/swes/2.0\"\n",
    "  xsi:schemaLocation=\"http://www.w3.org/2003/05/soap-envelope http://www.w3.org/2003/05/soap-envelope/soap-envelope.xsd http://www.opengis.net/sos/2.0 http://schemas.opengis.net/sos/2.0/sos.xsd\"\n",
    ">\n",
    "    <soap12:Header>\n",
    "        <wsa:To>http://www.ogc.org/SOS</wsa:To>\n",
    "        <wsa:Action>http://www.opengis.net/def/serviceOperation/sos/foiRetrieval/2.0/GetFeatureOfInterest</wsa:Action>\n",
    "        <wsa:ReplyTo>\n",
    "            <wsa:Address>http://www.w3.org/2005/08/addressing/anonymous</wsa:Address>\n",
    "        </wsa:ReplyTo>\n",
    "        <wsa:MessageID>0</wsa:MessageID>\n",
    "    </soap12:Header>\n",
    "    <soap12:Body>\n",
    "        <sos:GetFeatureOfInterest service=\"SOS\" version=\"2.0.0\">\n",
    "            <sos:observedProperty>{observation}</sos:observedProperty>\n",
    "            <sos:temporalFilter>\n",
    "                <fes:During>\n",
    "                    <fes:ValueReference>om:phenomenonTime</fes:ValueReference>\n",
    "                    <gml:TimePeriod gml:id=\"tp1\">\n",
    "                        <gml:beginPosition>{t_start}</gml:beginPosition>\n",
    "                        <gml:endPosition>{t_end}</gml:endPosition>\n",
    "                    </gml:TimePeriod>\n",
    "                </fes:During>\n",
    "            </sos:temporalFilter>\n",
    "        </sos:GetFeatureOfInterest>\n",
    "    </soap12:Body>\n",
    "</soap12:Envelope>\n",
    "'''\n",
    "\n",
    "###################\n",
    "\n",
    "def _fmt_time(time=None):\n",
    "    if time is None:\n",
    "        time = (datetime.datetime(1980, 1, 1),\n",
    "                datetime.datetime.now())\n",
    "\n",
    "    t_start, t_end = (t.isoformat() for t in time)\n",
    "    return dict(t_start=t_start, t_end=t_end)\n",
    "\n",
    "####################\n",
    "\n",
    "def _parse_station_data(text):\n",
    "    def parse_pos(pos):\n",
    "        if pos is None:\n",
    "            return None\n",
    "        return tuple(_parse_float(x)\n",
    "                     for x in pos.split(' '))\n",
    "\n",
    "    root = lxml.etree.fromstring(text)\n",
    "\n",
    "    data = [[e.text for e in root.findall('.//{http://www.opengis.net/gml/3.2}' + t)]\n",
    "            for t in ['name', 'identifier', 'pos']]\n",
    "\n",
    "    return [SimpleNamespace(name=name, url=url, pos=parse_pos(pos))\n",
    "            for name, url, pos in zip(*data)]\n",
    "\n",
    "####################\n",
    "\n",
    "def _parse_float(x):\n",
    "    if x is None:\n",
    "        return float('nan')\n",
    "    try:\n",
    "        return float(x)\n",
    "    except ValueError:\n",
    "        return float('nan')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations = get_stations()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations[0].name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "vars(stations[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "len(stations)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations_df = pd.DataFrame([])\n",
    "count = 0\n",
    "total_count = len(stations)\n",
    "\n",
    "for station in stations:\n",
    "    station_dict = vars(station)\n",
    "    \n",
    "    stations_df = stations_df.append(station_dict, ignore_index=True)\n",
    "    count = count + 1\n",
    "    \n",
    "    print(\"this is {} of {}\".format(count, total_count))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations_df.iloc[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "stations_df.to_csv(r'\\home\\jovyan\\binder\\stations.csv',index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "current_path = os.getcwd()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "current_path"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from os import listdir\n",
    "from os.path import isfile, join\n",
    "onlyfiles = [f for f in listdir(current_path) if isfile(join(current_path, f))]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "onlyfiles"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Source code from GA Github"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Scraping some BOM data\n",
    "\"\"\"\n",
    "import datetime\n",
    "import pytz\n",
    "import ciso8601\n",
    "from types import SimpleNamespace\n",
    "import requests\n",
    "import lxml\n",
    "import lxml.etree\n",
    "\n",
    "__all__ = (\n",
    "    'get_stations',\n",
    "    'get_station_data',\n",
    "    'mk_station_selector',\n",
    ")\n",
    "\n",
    "def get_stations(time=None,\n",
    "                 observation='http://bom.gov.au/waterdata/services/parameters/Water Course Discharge',\n",
    "                 url='http://www.bom.gov.au/waterdata/services'):\n",
    "    \"\"\" Get list of stations\n",
    "        :param time: tuple of datetime.datetime objects, or None to query from 1980-1-1 to Now\n",
    "        Returns\n",
    "        ========\n",
    "        List of stations:\n",
    "         .name -- string, human readable station name\n",
    "         .pos  -- Coordinate of the station or None\n",
    "         .url  -- service url identifier\n",
    "    \"\"\"\n",
    "\n",
    "    data = tpl_get_stations.format(observation=observation,\n",
    "                                   **_fmt_time(time))\n",
    "    rr = requests.post(url, data=data)\n",
    "\n",
    "    return _parse_station_data(rr.text)\n",
    "\n",
    "\n",
    "def get_station_data(station,\n",
    "                     time=None,\n",
    "                     observation='http://bom.gov.au/waterdata/services/parameters/Water Course Discharge',\n",
    "                     url='http://www.bom.gov.au/waterdata/services'):\n",
    "    \"\"\"\n",
    "    Query Gauge Data.\n",
    "    :param station: One of the stations see get_stations\n",
    "    :param time: tuple of datetime.datetime objects, or None to query from 1980-1-1 to Now\n",
    "    Returns\n",
    "    ========\n",
    "    Pandas dataframe with Timestamp(index), Value columns\n",
    "    \"\"\"\n",
    "\n",
    "    data = tpl_get_obs.format(station=station.url,\n",
    "                              observation=observation,\n",
    "                              **_fmt_time(time))\n",
    "    rr = requests.post(url, data=data)\n",
    "    return _parse_get_data(rr.text)\n",
    "\n",
    "\n",
    "def mk_station_selector(on_select,\n",
    "                        stations=None,\n",
    "                        dst_map=None,\n",
    "                        **kw):\n",
    "    \"\"\"\n",
    "    Add stations to the map and register on_click event.\n",
    "    :param on_select: Will be called when user selects station on the map `on_select(station)`\n",
    "    :param stations: List of stations as returned from get_stations\n",
    "    :param dst_map: Map to add stations markers to\n",
    "    Any other arguments are passed on  to Map(..) constructor.\n",
    "    Returns\n",
    "    =======\n",
    "    (map, marker_cluster)\n",
    "    Passes through map=dst_map if not None, or returns newly constructed Map object.\n",
    "    \"\"\"\n",
    "    import ipyleaflet as L\n",
    "\n",
    "    if stations is None:\n",
    "        stations = get_stations()\n",
    "\n",
    "    stations = [st for st in stations if st.pos is not None]\n",
    "    pos2st = {st.pos: st for st in stations}\n",
    "\n",
    "    def on_click(event='', type='', coordinates=None):\n",
    "        pos = tuple(coordinates)\n",
    "        st = pos2st.get(pos)\n",
    "        if st is None:\n",
    "            # should probably log warning here\n",
    "            print(\"Can't map click to station\")\n",
    "            return\n",
    "\n",
    "        on_select(st)\n",
    "\n",
    "    markers = [L.Marker(location=st.pos,\n",
    "                        draggable=False,\n",
    "                        title=st.name)\n",
    "               for st in stations]\n",
    "\n",
    "    cluster = L.MarkerCluster(markers=markers)\n",
    "\n",
    "    if dst_map is None:\n",
    "        dst_map = L.Map(**kw)\n",
    "\n",
    "    dst_map.add_layer(cluster)\n",
    "    cluster.on_click(on_click)\n",
    "\n",
    "    return dst_map, cluster\n",
    "\n",
    "\n",
    "def ui_select_station(stations,\n",
    "                      zoom=3,\n",
    "                      center=(-24, 138),\n",
    "                      **kw):\n",
    "    \"\"\"\n",
    "    Returns\n",
    "    =======\n",
    "    (gauge_data, station)\n",
    "    \"\"\"\n",
    "    import ipywidgets as W\n",
    "    from IPython.display import display\n",
    "    import matplotlib.pyplot as plt\n",
    "    import ipyleaflet as L\n",
    "    from odc.ui import ui_poll\n",
    "\n",
    "    dbg_display = W.Output()\n",
    "    fig_display = W.Output()\n",
    "    btn_done = W.Button(description='Done')\n",
    "    scroll_wheel_zoom = kw.pop('scroll_wheel_zoom', True)\n",
    "    map_widget = L.Map(zoom=zoom,\n",
    "                       center=center,\n",
    "                       scroll_wheel_zoom=scroll_wheel_zoom,\n",
    "                       **kw)\n",
    "\n",
    "    state = SimpleNamespace(pos=None,\n",
    "                            gauge_data=None,\n",
    "                            finished=False,\n",
    "                            station=None)\n",
    "\n",
    "    plt_interactive_state = plt.isinteractive()\n",
    "    plt.interactive(False)\n",
    "\n",
    "    with fig_display:\n",
    "        fig, ax = plt.subplots(1, figsize=(14,4))\n",
    "        ax.set_visible(False)\n",
    "        display(fig)\n",
    "\n",
    "    def _on_select(station):\n",
    "        if state.finished:\n",
    "            print('Please re-run the cell')\n",
    "            return\n",
    "\n",
    "        state.station = station\n",
    "        state.pos = station.pos\n",
    "        state.gauge_data = None\n",
    "\n",
    "        print('Fetching data for: {}'.format(station.name))\n",
    "        try:\n",
    "            xx = get_station_data(station).dropna()\n",
    "        except Exception:\n",
    "            print('Failed to read data')\n",
    "            return\n",
    "        print('Got {} observations'.format(xx.shape[0]))\n",
    "\n",
    "        state.gauge_data = xx\n",
    "\n",
    "        with fig_display:\n",
    "            ax.clear()\n",
    "            ax.set_visible(True)\n",
    "            xx.plot(ax=ax)\n",
    "            ax.set_xlabel(\"Date\")\n",
    "            ax.set_ylabel(\"Cubic meters per second\")\n",
    "            ax.legend([station.name])\n",
    "\n",
    "        fig_display.clear_output(wait=True)\n",
    "        with fig_display:\n",
    "            display(fig)\n",
    "\n",
    "    def on_select(station):\n",
    "        with dbg_display:\n",
    "            _on_select(station)\n",
    "\n",
    "    def on_done(btn):\n",
    "        if state.finished:\n",
    "            with dbg_display:\n",
    "                print('Please re-run the cell')\n",
    "                return\n",
    "\n",
    "        state.finished = True\n",
    "        n_obs = 0 if state.gauge_data is None else state.gauge_data.shape[0]\n",
    "\n",
    "        with dbg_display:\n",
    "            print('''Finished\n",
    "Station: {}\n",
    "Number of Observations: {}'''.format(state.station.name, n_obs))\n",
    "\n",
    "    def on_poll():\n",
    "        with dbg_display:\n",
    "            if state.finished:\n",
    "                return state.gauge_data, state.station\n",
    "            return None\n",
    "\n",
    "    mk_station_selector(on_select,\n",
    "                        stations=stations,\n",
    "                        dst_map=map_widget)\n",
    "\n",
    "    ## UI:\n",
    "    ##\n",
    "    ##  MMMMMMMMMMMMM BBBBB\n",
    "    ##  MMMMMMMMMMMMM .....\n",
    "    ##  MMMMMMMMMMMMM .....\n",
    "    ##  MMMMMMMMMMMMM .....\n",
    "    ##  MMMMMMMMMMMMM .....\n",
    "    ##  FFFFFFFFFFFFFFFFFFF\n",
    "    ##  FFFFFFFFFFFFFFFFFFF\n",
    "\n",
    "    #  M - Map     F - Figure\n",
    "    #  B - Button  . - Debug output\n",
    "\n",
    "    btn_done.on_click(on_done)\n",
    "    r_panel = W.VBox([btn_done, dbg_display],\n",
    "                     layout=W.Layout(width='30%'))\n",
    "\n",
    "    ui = W.VBox([W.HBox([map_widget, r_panel]),\n",
    "                 fig_display])\n",
    "\n",
    "    display(ui)\n",
    "\n",
    "    result = ui_poll(on_poll, 1/20)  # this will block until done is pressed\n",
    "\n",
    "    #restore interactive state\n",
    "    fig_display.clear_output(wait=True)\n",
    "    with fig_display:\n",
    "        plt.interactive(plt_interactive_state)\n",
    "        plt.show()\n",
    "\n",
    "    return result\n",
    "\n",
    "\n",
    "def _fmt_time(time=None):\n",
    "    if time is None:\n",
    "        time = (datetime.datetime(1980, 1, 1),\n",
    "                datetime.datetime.now())\n",
    "\n",
    "    t_start, t_end = (t.isoformat() for t in time)\n",
    "    return dict(t_start=t_start, t_end=t_end)\n",
    "\n",
    "def _parse_float(x):\n",
    "    if x is None:\n",
    "        return float('nan')\n",
    "    try:\n",
    "        return float(x)\n",
    "    except ValueError:\n",
    "        return float('nan')\n",
    "\n",
    "def _parse_time(x):\n",
    "    t = ciso8601.parse_datetime(x).astimezone(pytz.utc)\n",
    "    return t.replace(tzinfo=None)\n",
    "\n",
    "\n",
    "def _parse_get_data(text, raw=False):\n",
    "    root = lxml.etree.fromstring(text)\n",
    "\n",
    "    data = [[e.text for e in root.findall('.//{http://www.opengis.net/waterml/2.0}' + t)]\n",
    "            for t in ['time', 'value']]\n",
    "\n",
    "    dd = [(_parse_time(t),\n",
    "           _parse_float(v))\n",
    "          for t, v in zip(*data)]\n",
    "\n",
    "    if raw:\n",
    "        return dd\n",
    "\n",
    "    import pandas as pd\n",
    "    return pd.DataFrame(dd, columns=('Timestamp', 'Value')).set_index('Timestamp')\n",
    "\n",
    "\n",
    "def _parse_station_data(text):\n",
    "    def parse_pos(pos):\n",
    "        if pos is None:\n",
    "            return None\n",
    "        return tuple(_parse_float(x)\n",
    "                     for x in pos.split(' '))\n",
    "\n",
    "    root = lxml.etree.fromstring(text)\n",
    "\n",
    "    data = [[e.text for e in root.findall('.//{http://www.opengis.net/gml/3.2}' + t)]\n",
    "            for t in ['name', 'identifier', 'pos']]\n",
    "\n",
    "    return [SimpleNamespace(name=name, url=url, pos=parse_pos(pos))\n",
    "            for name, url, pos in zip(*data)]\n",
    "\n",
    "\n",
    "\n",
    "# observation = 'http://bom.gov.au/waterdata/services/parameters/Water Course Discharge'\n",
    "#\n",
    "tpl_get_stations = '''\n",
    "<soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"\n",
    "  xmlns:sos=\"http://www.opengis.net/sos/2.0\"\n",
    "  xmlns:wsa=\"http://www.w3.org/2005/08/addressing\"\n",
    "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n",
    "  xmlns:ows=\"http://www.opengis.net/ows/1.1\"\n",
    "  xmlns:fes=\"http://www.opengis.net/fes/2.0\"\n",
    "  xmlns:gml=\"http://www.opengis.net/gml/3.2\"\n",
    "  xmlns:swes=\"http://www.opengis.net/swes/2.0\"\n",
    "  xsi:schemaLocation=\"http://www.w3.org/2003/05/soap-envelope http://www.w3.org/2003/05/soap-envelope/soap-envelope.xsd http://www.opengis.net/sos/2.0 http://schemas.opengis.net/sos/2.0/sos.xsd\"\n",
    ">\n",
    "    <soap12:Header>\n",
    "        <wsa:To>http://www.ogc.org/SOS</wsa:To>\n",
    "        <wsa:Action>http://www.opengis.net/def/serviceOperation/sos/foiRetrieval/2.0/GetFeatureOfInterest</wsa:Action>\n",
    "        <wsa:ReplyTo>\n",
    "            <wsa:Address>http://www.w3.org/2005/08/addressing/anonymous</wsa:Address>\n",
    "        </wsa:ReplyTo>\n",
    "        <wsa:MessageID>0</wsa:MessageID>\n",
    "    </soap12:Header>\n",
    "    <soap12:Body>\n",
    "        <sos:GetFeatureOfInterest service=\"SOS\" version=\"2.0.0\">\n",
    "            <sos:observedProperty>{observation}</sos:observedProperty>\n",
    "            <sos:temporalFilter>\n",
    "                <fes:During>\n",
    "                    <fes:ValueReference>om:phenomenonTime</fes:ValueReference>\n",
    "                    <gml:TimePeriod gml:id=\"tp1\">\n",
    "                        <gml:beginPosition>{t_start}</gml:beginPosition>\n",
    "                        <gml:endPosition>{t_end}</gml:endPosition>\n",
    "                    </gml:TimePeriod>\n",
    "                </fes:During>\n",
    "            </sos:temporalFilter>\n",
    "        </sos:GetFeatureOfInterest>\n",
    "    </soap12:Body>\n",
    "</soap12:Envelope>\n",
    "'''\n",
    "\n",
    "# {station}, {observation}, {t_start}, {t_end}\n",
    "tpl_get_obs = '''\n",
    "<soap12:Envelope xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\"\n",
    "                 xmlns:sos=\"http://www.opengis.net/sos/2.0\"\n",
    "                 xmlns:wsa=\"http://www.w3.org/2005/08/addressing\"\n",
    "                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n",
    "                 xmlns:ows=\"http://www.opengis.net/ows/1.1\"\n",
    "                 xmlns:fes=\"http://www.opengis.net/fes/2.0\"\n",
    "                 xmlns:gml=\"http://www.opengis.net/gml/3.2\"\n",
    "                 xmlns:swes=\"http://www.opengis.net/swes/2.0\"\n",
    "                 xsi:schemaLocation=\"http://www.w3.org/2003/05/soap-envelope http://www.w3.org/2003/05/soap-envelope/soap-envelope.xsd http://www.opengis.net/sos/2.0 http://schemas.opengis.net/sos/2.0/sos.xsd\"\n",
    ">\n",
    "    <soap12:Header>\n",
    "        <wsa:To>http://www.ogc.org/SOS</wsa:To>\n",
    "        <wsa:Action>http://www.opengis.net/def/serviceOperation/sos/core/2.0/GetObservation</wsa:Action>\n",
    "        <wsa:ReplyTo>\n",
    "            <wsa:Address>http://www.w3.org/2005/08/addressing/anonymous</wsa:Address>\n",
    "        </wsa:ReplyTo>\n",
    "        <wsa:MessageID>0</wsa:MessageID>\n",
    "    </soap12:Header>\n",
    "    <soap12:Body>\n",
    "        <sos:GetObservation service=\"SOS\" version=\"2.0.0\">\n",
    "            <sos:procedure>http://bom.gov.au/waterdata/services/tstypes/Pat4_C_B_1_DailyMean</sos:procedure>\n",
    "            <sos:observedProperty>{observation}</sos:observedProperty>\n",
    "            <sos:featureOfInterest>{station}</sos:featureOfInterest>\n",
    "            <sos:temporalFilter>\n",
    "                <fes:During>\n",
    "                    <fes:ValueReference>om:phenomenonTime</fes:ValueReference>\n",
    "                    <gml:TimePeriod gml:id=\"tp1\">\n",
    "                        <gml:beginPosition>{t_start}</gml:beginPosition>\n",
    "                        <gml:endPosition>{t_end}</gml:endPosition>\n",
    "                    </gml:TimePeriod>\n",
    "                </fes:During>\n",
    "            </sos:temporalFilter>\n",
    "        </sos:GetObservation>\n",
    "    </soap12:Body>\n",
    "</soap12:Envelope>\n",
    "'''"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
